import json
import requests
import os
import simfile.dir
import subprocess
import pathlib
from tqdm import tqdm
import traceback # print(traceback.format_exc()) to get full trace to debug

songs_path = '/home/dance/Desktop/Songs'

total_files = 0
exclude = ['VERSION', 'ORIGIN', 'CDIMAGE', 'DISCIMAGE', 'LYRICSPATH', 'CDTITLE', 'MUSIC', 'OFFSET', 'SAMPLESTART', 'SAMPLELENGTH', 'SELECTABLE', 'STOPS', 'DELAYS', 'WARPS', 'TIMESIGNATURES', 'TICKCOUNTS', 'COMBOS', 'SPEEDS', 'SCROLLS', 'FAKES', 'LABELS', 'BGCHANGES', 'KEYSOUNDS', 'ATTACKS', 'CHARTSTYLE', 'RADARVALUES', 'NOTES', 'FGCHANGES']

class ScriptException(Exception):
    def __init__(self, returncode, stdout, stderr, script):
        self.returncode = returncode 
        self.stdout = stdout
        self.stderr = stderr
        Exception().__init__('Error in script')

def sanitize_banner(path):
    return os.path.normpath(path).replace('..', '').replace('/','')

def sanitize_path(path):
    return os.path.normpath(path).replace("$", "\\$")
        
def parser():
    packs = os.listdir(songs_path)
    data = {}
    for pack in packs:
        pack_data = {}
        song_data = []
        try:
            pack = simfile.dir.SimfilePack(songs_path + '/' + pack)
        except:
            continue
        else:
            if pack.banner():
                pack_data["BANNER_PATH"] = '/'.join(pack.banner().split('/')[-2:])
                pack_data["BANNER"] = pack.banner().split('/')[-2]

                # do not allow query parameter
                pack_data["BANNER_PATH"], pack_data["BANNER"]  = pack_data["BANNER_PATH"].replace('?',''), pack_data["BANNER"].replace('?','')

                # set invalid banner to empty string
                if not (os.path.exists(pack_data["BANNER_PATH"]) and is_image_path(pack_data["BANNER_PATH"])):
                    pack_data["BANNER"] = ""
                    pack_data["BANNER_PATH"] = ""
            else:
                # set path to empty string when banner does not exist (if this is not set it will mess up checks later)
                pack_data["BANNER_PATH"] = ""

            path_iterator = pack.simfile_dirs()
            try:
                total_files = sum(1 for pack in data for song in data[pack]["SONGS"] if song["BANNER_PATH"] and song["BANNER"] and os.path.exists(song["BANNER_PATH"]) and is_image_path(song["BANNER_PATH"]))
                total_files += sum(1 for pack in data if data[pack]["BANNER_PATH"] and data[pack]["BANNER"] and os.path.exists(data[pack]["BANNER_PATH"]) and is_image_path(data[pack]["BANNER_PATH"]))

                for song in pack.simfiles():
                    song["BANNER_PATH"] = os.path.join(os.path.dirname(next(path_iterator).simfile_path), song.banner).replace(songs_path + '/', '')
                    song["BANNER"] = pack.name + ' _ ' + song.title

                    # do not allow query parameter
                    song["BANNER_PATH"] = song["BANNER_PATH"].replace('?','')
                    song["BANNER"] = song["BANNER"].replace('?','')

                    # set invalid banner to None
                    if not (os.path.exists(song["BANNER_PATH"]) and is_image_path(song["BANNER_PATH"])):
                        song["BANNER"] = None
                        song["BANNER_PATH"] = None
                    
                    # get rid of unnecessary data
                    for i, chart in enumerate(song.charts):
                        updated_chart = {k: v for k, v in chart.items() if k not in exclude}
                        song.charts[i] = updated_chart
                    song["CHARTS"] = song.charts.data

                    # get rid of unnecessary data
                    song  = {k: v for k, v in song.items() if k not in exclude}

                    song_data.append(song)
            except Exception as e:
                print(f"Error processing song: {e}")
                continue

            pack_data["SONGS"] = song_data
            data[pack.name] = pack_data
    write_to_json(data)
    print("Sending data to dgab@apphost.ocf.berkeley.edu")
    send_output(data)
    
def convert_to_webp(bannerpath):
    script = f'cwebp -q 60 "{sanitize_path(bannerpath)}" -o "banners/{b}.webp"'
    proc = subprocess.Popen(['bash', '-c', script], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = proc.communicate()
    if proc.returncode:
        print(f"Error in script {script}: {proc.returncode} {stdout} {stderr}")
        print(traceback.format_exc())
        return bannerpath
    return f'/home/remy/sm-parser/banners/{b}.webp'

def send_output(data):
    try:
        print("Sending banner images to dgab@apphost.ocf.berkeley.edu")
   
        total_files = sum(1 for pack in data for song in data[pack]["SONGS"] if song["BANNER_PATH"] and song["BANNER"] and os.path.exists(song["BANNER_PATH"]) and is_image_path(song["BANNER_PATH"]))
        total_files += sum(1 for pack in data if data[pack]["BANNER_PATH"] and data[pack]["BANNER"] and os.path.exists(data[pack]["BANNER_PATH"]) and is_image_path(data[pack]["BANNER_PATH"]))

        with tqdm(total=total_files, desc="Transferring files") as pbar:
            for pack in data:
                if data[pack]["BANNER_PATH"] and os.path.exists(data[pack]["BANNER_PATH"]):
                    print("pack banner: ", data[pack]["BANNER_PATH"])
                    # convert banner to webp
                    # data[pack]["BANNER_PATH"] = convert_to_webp(data[pack]["BANNER_PATH"])
                    # copy to ocf server
                    script = f'scp -r "{sanitize_path(data[pack]["BANNER_PATH"])}" dgab@apphost.ocf.berkeley.edu:/home/d/dg/dgab/banner/"{sanitize_banner(data[pack]["BANNER"])}"'
                    proc = subprocess.Popen(['bash', '-c', script], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    stdout, stderr = proc.communicate()
                    if proc.returncode:
                        print(f"Error in script {script}: {proc.returncode} {stdout} {stderr}")
                        continue
                    pbar.update(1)
                for song in data[pack]["SONGS"]:
                    if song["BANNER_PATH"] and os.path.exists(song["BANNER_PATH"]):
                        # convert banner to webp
                        print("song banner: ", song["BANNER_PATH"])
                        # song["BANNER_PATH"] = convert_to_webp(song["BANNER_PATH"])
                        # copy to ocf server
                        script = f'scp -r "{sanitize_path(song["BANNER_PATH"])}" dgab@apphost.ocf.berkeley.edu:/home/d/dg/dgab/banner/"{sanitize_banner(song["BANNER"])}"'
                        proc = subprocess.Popen(['bash', '-c', script], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                        stdout, stderr = proc.communicate()
                        if proc.returncode:
                            print(f"Error in script {script}: {proc.returncode} {stdout} {stderr}")
                            continue
                        pbar.update(1)
        print("Sending songs.json to dgab@apphost.ocf.berkeley.edu")
        script = 'scp -r songs.json dgab@apphost.ocf.berkeley.edu:/home/d/dg/dgab/songlist/'
        proc = subprocess.Popen(['bash', '-c', script])
        stdout, stderr = proc.communicate()
        if proc.returncode:
            print(f"Error in script {script}: {proc.returncode} {stdout} {stderr}")
        else:
            print(f"Data sent successfully")
    except requests.exceptions.RequestException as e:
        print(f"Bash script error: {e}")

def write_to_json(data):
    with open('songs.json', 'w') as file:
        json.dump(data, file, indent=4)
    print("Data written to songs.json")

def is_image_path(path):
    image_extensions = ['.png', '.jpg', '.jpeg', '.gif', '.webp']
    return any(path.lower().endswith(ext) for ext in image_extensions)

parser()